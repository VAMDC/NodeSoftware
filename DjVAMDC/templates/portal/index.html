{% extends "indigo.html" %}
{% load i18n %}
{% block title %}VAMDC{% endblock %}

{% block headline %}VAMDC Testsite{% endblock %}

{% block content %}
<div class="descr">April 23, 2010 by Thomas</div>

<p> This is a test implementation of a VAMDC portal. It consists of
two parts that are run by independant web-applications:</p>

<ul>
<li>The <strong>portal</strong> which is the VAMDC "central" that is
supposed to let users <a href="/portal/query/">make a data request</a>
without knowing about individial databases, to pass this request to
the connected databases and to collect the results to be displayed or
downloaded to the user. All URLs that contain <em>/portal/</em> are
run by this application.</li>
<li>The <strong>nodes</strong> which represent a data set, typically a
database, with the software running on top of it that allows
communication with the portal. Nodes have URLs with <em>/node/</em>
and as you can see, there is currently just
one: <a href="/node/vald">VALD</a>.</li>
</ul>

<p><strong>Note:</strong> Even though both applications
(<em>/portal/</em> and <em>/node/</em>) run on the same server for
test purposes, there is no "cheating" in the sense that they share
running code. They only communicate via standard HTTP-interfaces which
are important parts to be developed and tested.
</p>

<p>Questions and feedback are welcome at <em>thomas.marquart@fysast.uu.se</em>.</p>

<p><strong>Read on for more details about what happend behind the scenes &raquo; </strong></p>
<p/>
<p/>
<p/>

<h3>The Framework and its benefits</h3>

<p>Both the portal and the nodes are based <a href="http://www.djangoproject.com/">Django</a>. This is
a wide-spread framework for websites and services, written in the
Python programming language, open-source and well documented. In
short, it offers a database abstraction layer, a comfortable way to
associate URLs with bits of code and a templating engine. It also
facilitates the creation and use of HTML forms and provides an admin
interface.</p>

<h3>The Publishing Tools with Django</h3>

<p>The task of the publishing tools is to provide three things:
<ul><li>import tool of data into a relational database</li>
<li>the database itself</li>
<li>the softare on top of the database that provides the standard VAMDC interfaces.</li>
</ul>
</p>

<p>One advantage of using Django is that the database model is defined in
an abstract way (for the example of VALD
look <a href="http://github.com/ivh/VAMDC-VALD/blob/master/DjVALD/vald/models.py">here</a>). The
tools that come with Django then take care of the table creation when
the database is initialized. This makes out tools more independant
from the start and since Django has backends for all major open-source
databases, a later switch of the database engine will be no big
problem.</p>

<p>The database access with Django is also abstracted. This has at least
two major advantages. For one, it offers additional funcionality, for
example an easy way to use references bewteen tables both ways and to
traverse table boundareis. To illustrate: In the case of VALD, each
transition entry holds two references to entries in the state-table
(upper and lower). In Django code, I can
e.g. write <em>transition.upperstate.energy</em> (use value from
state table as if it was in the transition table)
or <em>state.isupperstatefor</em> to get all the transitions which
have this state as upper state (using the key in reverse direction).</p>

<p>The second major advantage is that this abstraction layer is just what
we need to "hide" the custom layout of each database and access it in
a unified way. This will facilitate both the parsing and execution of
the generic query language as recieved from the VAMDC portal, as well
as the generation of standard output data, without adapting the
relevant code. This is because the model definition also "translates"
between table names and exposed names.</p>

<p>Basically, all that will be needed to be written for a new VAMDC
database, is the model definition.</p>

<p>Concerning the import tool, we are still testing whether to use the
Django abstraction for filling the tables, or to access the database
(with empty tables prepared by Django) directly.</p>


<p>The implementation of the software on top of the database (recieving
queries, running them and preparing output in standard format) is also
much facilitated. To write a recieving interface according to TAP is
almost trivial because Django provides ready high-level tools for HTTP
POST and GET data, HTTP headers and communication details and the
mapping of standard URLs to code.

<p>The data output is another important point. It has been stated that
the overhead of creating and transferring XML (XSAMS Schema) will be
significant. We have implemented this for VALD, at first using Djangos
template engine (which helped making this quite easy). For a typical
query that produces 5 MB of uncompressed XSAMS data, the rendering of
the template (i.e. looping over the relevant bits, filling in values
at the right places) took indeed on the order of 5 seconds. There was
however no significant difference when the same data were written into
comma-separated tables. In compressed format (gzip) the size
difference was less than 1.5.</p>

<p>Although the template rendering was already a factor of 5 improvement
over previous, more naive implementations, we have in the meantime
abandoned the use of Djangos template engine for the creation of data
output. For it seems to be the fact that a large structure has to be
created and held in memory that slows things down. Python has
so-called generators which are basically functions that "yield" their
output only while looped over. Converting the XSAMS-template into a set
of nested generators, and handing these in their unevalutated state to
the HTTP-reply allows the reply to start immediately while the
data-stream is constantly created. Together with the
fact that database queries with Djangos abstraction layer are not
actually evaluated until the data is needed, this results in a direct
"pipeline" from the database to the HTTP-output in which at no point
all data is held in memory.</p>

<p>This made the aforementioned request finish in a little over 1
second, including transfer. The web server (Apache) that runs the
Django application, is configured to compress the reply (all modern
web-browsers support recieving this) and this way it became possible
to have <em>synchronous</em> data requests that deliver significant
amounts of data in a timeframe that is acceptable for users. (see the
example at the <a href="">VALD Node</a>)</p>

<p>Also once more, the difference between XSAMS and CSV or VO-Tables is
negligible if the same information is sent. However this will be
different, if a the layout of a dataset does not fit very well with
the strict XML Schema and requires significant logic every time a
XSAMS document is assembled. In this case it might be worth
considering to pre-calculate the neccessary steps once and for all at
import time (as we for example have done with VALD by splitting the
states from the transitions).</p>


<h3>The Portal with Django</h3>

<p>Even though the portal is not primarily our responsibility, we wanted
to have somethig to test the interfaces with. Setting up the simple
query form as it is now was straight forward with Django. The portal
assigns a random string as ID to each query and saves it with a
timestamp into its own database when it is submitted. The user then
gets redirected to the result page for that query which is the one
that actually sends out the request to all the nodes in the "registry"
(just a list of names and urls to the TAP-sync interface for now) and
displays the results inline.</p>


<p>Generally, we would like to suggest to base the real VAMDC portal on
something like Django. It brings all the necessary tools with it
(e.g. authentification) while allowing much flexibility at the same
time.</p>

<p>A note on the query language: As you can see on any result page (look
at the query string), we simply use numbered placeholders for the
different parameters at the portal. The node then simply resolves these with its own
dictionary
(see <a href="http://github.com/ivh/VAMDC-VALD/blob/master/DjVALD/vald/views.py">here</a>),
thereby automatically having a query in its own namespace.</p>

{% endblock %}

